
#include "Motors.h"         
#include "PID.h"            
#include "Kinematics.h"  
#include "BumpSensors.h"    // 使用bump传感器代替line sensors
#include <math.h>
#include "Encoders.h"

// ========== 基础组件 ==========
Motors_c motors;    
Kinematics_c pose; 
BumpSensors_c bump_sensors;  // bump传感器对象

PID_c turn_pid;  // 用于旋转控制的PID

// ========== 速度估计变量 ==========
unsigned long speed_est_ts = 0;
#define SPEED_EST_MS 10
long last_e0 = 0;
long last_e1 = 0;
float speed_right = 0.0f;
float speed_left  = 0.0f;

// ========== Leader跟随参数 ==========
const bool DEBUG_SERIAL = true;
const float TURN_BASE_SPEED = 20.0f;    // 原地旋转基础速度（PWM）
const float TURN_MAX_SPEED = 40.0f;     // 最大旋转速度

// ⚠️ Bump传感器检测阈值
const float IR_THRESHOLD = 10.0f;        // IR信号检测阈值
const float ALIGNMENT_TOLERANCE = 20.0f; // 对齐容差

// ========== 更新位姿 ==========
void updatePose(){
  static unsigned long pose_ts = 0;
  if ( millis() - pose_ts >= 10 ) { 
    pose_ts = millis(); 
    pose.update(); 
  }
}

// ========== 原地旋转跟随Leader（使用bump传感器）==========
void followLeaderInPlace() {
  // 读取bump传感器的IR信号差值
  float ir_balance = bump_sensors.getBalance();
  
  // 获取信号变化量
  float signal_change = bump_sensors.getSignalChange();
  float signal_diff = fabs(ir_balance);
  
  // 检查是否检测到Leader
  // 如果信号变化不明显，说明没有Leader
  if (fabs(signal_change) < 30.0f && signal_diff < IR_THRESHOLD) {
    // 没有检测到Leader
    motors.setPWM(0, 0);
    turn_pid.reset();  // 重置PID
    if (DEBUG_SERIAL) {
      static unsigned long debug_ts = 0;
      if (millis() - debug_ts >= 500) {
        debug_ts = millis();
        Serial.println("========================================");
        Serial.println("未检测到Leader（bump传感器无明显信号）");
        Serial.print("信号变化: "); Serial.print(signal_change, 2);
        Serial.print(" | 左右差值: "); Serial.println(signal_diff, 2);
        Serial.print("当前读数 - 左: "); Serial.print(bump_sensors.readings[0], 2);
        Serial.print(" | 右: "); Serial.println(bump_sensors.readings[1], 2);
        Serial.print("背景值 - 左: "); Serial.print(bump_sensors.background[0], 2);
        Serial.print(" | 右: "); Serial.println(bump_sensors.background[1], 2);
        Serial.println("\n提示：");
        Serial.println("  1. 将Leader靠近Follower（5-15cm）");
        Serial.println("  2. 确保Leader的IR发射器开启");
        Serial.println("  3. Bump传感器在机器人前方两侧");
        Serial.println("========================================");
      }
    }
    return;
  }
  
  // 根据IR差值计算旋转方向和速度
  if (fabs(ir_balance) < ALIGNMENT_TOLERANCE) {
    // 已对齐，停止旋转
    motors.setPWM(0, 0);
    turn_pid.reset();  // 重置PID
    if (DEBUG_SERIAL) {
      static unsigned long debug_ts = 0;
      if (millis() - debug_ts >= 500) {
        debug_ts = millis();
        Serial.println("========================================");
        Serial.println("✓✓✓ 已对齐Leader！✓✓✓");
        Serial.print("IR差值: "); Serial.print(ir_balance, 2);
        Serial.print(" | 信号变化: "); Serial.println(signal_change, 2);
        Serial.print("左bump: "); Serial.print(bump_sensors.readings[0], 2);
        Serial.print(" | 右bump: "); Serial.println(bump_sensors.readings[1], 2);
        Serial.println("========================================");
      }
    }
  } else {
    // 需要旋转对齐 - 使用PID控制
    // 目标：让ir_balance趋近于0
    // 测量值：当前的ir_balance
    // 输出：旋转PWM
    
    // PID更新（每50ms）
    static unsigned long pid_ts = 0;
    if (millis() - pid_ts >= 50) {
      pid_ts = millis();
      
      // PID控制：目标是0（对齐），当前测量值是ir_balance
      float turn_pwm = turn_pid.update(0.0f, ir_balance);
      
      // 限制PWM范围
      turn_pwm = constrain(turn_pwm, -TURN_MAX_SPEED, TURN_MAX_SPEED);
      
      // 原地旋转：左右轮反向
      // 如果ir_balance为正（Leader在右），需要右转
      // 右转：左轮前进(+)，右轮后退(-)
      int left_pwm = (int)turn_pwm;
      int right_pwm = -(int)turn_pwm;
      
      motors.setPWM(left_pwm, right_pwm);
      
      if (DEBUG_SERIAL) {
        static unsigned long debug_ts = 0;
        if (millis() - debug_ts >= 200) {
          debug_ts = millis();
          Serial.println("----------------------------------------");
          Serial.print("跟随中 | IR差值: "); Serial.print(ir_balance, 2);
          Serial.print(" | 信号变化: "); Serial.println(signal_change, 2);
          Serial.print("PID输出: "); Serial.print(turn_pwm, 2);
          Serial.print(" | PWM L/R: "); Serial.print(left_pwm); 
          Serial.print("/"); Serial.println(right_pwm);
          Serial.print("Bump读数 - 左: "); Serial.print(bump_sensors.readings[0], 2);
          Serial.print(" | 右: "); Serial.println(bump_sensors.readings[1], 2);
          
          // 判断Leader在哪一侧
          if (ir_balance > 0) {
            Serial.println(">>> Leader在右侧，右转中 >>>");
          } else {
            Serial.println("<<< Leader在左侧，左转中 <<<");
          }
          Serial.println("----------------------------------------");
        }
      }
    }
  }
}

// ========== SETUP ==========
void setup() {
  // 初始化串口
  Serial.begin(9600);
  delay(1000);
  Serial.println("\n\n========================================");
  Serial.println("*** Follower - Leader跟随程序 ***");
  Serial.println("模式：原地旋转跟随（使用Bump传感器ADC）");
  Serial.println("========================================");

  // 初始化电机
  motors.initialise();

  // 初始化编码器
  setupEncoder0();
  setupEncoder1();

  // 初始化位姿
  pose.initialise(0, 0, 0);
  
  // 初始化bump传感器（ADC模式）
  bump_sensors.initialiseForADC();
  Serial.println("✓ Bump传感器已初始化（ADC模式）");
  Serial.println("  - 左bump: 引脚4");
  Serial.println("  - 右bump: 引脚5");
  Serial.println("  - EMIT_PIN: LOW（接收模式）");
  
  // 校准背景IR值
  bump_sensors.calibrateBackground();
  
  // 初始化旋转PID控制器
  // Kp: 比例增益 - 控制响应速度
  // Ki: 积分增益 - 消除稳态误差
  // Kd: 微分增益 - 减少超调
  turn_pid.initialise(0.40f, 0.005f, 0.4f);  // bump传感器PID参数
  turn_pid.reset();

  Serial.println("\n系统初始化完成");
  Serial.println("PID参数: Kp=0.40, Ki=0.005, Kd=0.4");
  Serial.println("⚠️  注意：Bump传感器在机器人前方两侧");
  Serial.println("建议：将Leader正对Follower前方（5-20cm）");
  Serial.println("Follower已准备好，等待检测Leader信号...");
  Serial.println("========================================\n");
  delay(2000);
}

// ========== LOOP ==========
void loop() {
  // 更新位姿
  updatePose();

  // 执行原地旋转跟随
  followLeaderInPlace();
  
  delay(10);
}

